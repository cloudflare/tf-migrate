#!/usr/bin/env bash

# clean-state-modules
# Removes specified modules from remote Terraform state in R2
# This is useful for cleaning up resources that have been manually deleted
# from Cloudflare but still exist in the Terraform state

set -euo pipefail

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# Show usage
show_usage() {
    echo "Usage: $0 <module_name> [module_name2 ...]"
    echo ""
    echo "Removes specified modules from the v4 remote Terraform state in R2."
    echo ""
    echo "Arguments:"
    echo "  module_name    Name of the module to remove (e.g., zero_trust_tunnel_cloudflared)"
    echo "                 Multiple modules can be specified"
    echo ""
    echo "Environment variables required:"
    echo "  R2_ACCESS_KEY_ID        R2 access key ID"
    echo "  R2_SECRET_ACCESS_KEY    R2 secret access key"
    echo ""
    echo "Examples:"
    echo "  # Remove tunnels module"
    echo "  $0 zero_trust_tunnel_cloudflared"
    echo ""
    echo "  # Remove multiple modules"
    echo "  $0 zero_trust_tunnel_cloudflared zero_trust_tunnel_cloudflared_route"
    echo ""
    echo "  # With explicit credentials"
    echo "  R2_ACCESS_KEY_ID=xxx R2_SECRET_ACCESS_KEY=yyy $0 zero_trust_tunnel_cloudflared"
    exit 1
}

# Check for help flag
if [[ $# -eq 0 ]] || [[ "${1:-}" == "-h" ]] || [[ "${1:-}" == "--help" ]]; then
    show_usage
fi

# Check for R2 credentials
if [[ -z "${R2_ACCESS_KEY_ID:-}" ]] || [[ -z "${R2_SECRET_ACCESS_KEY:-}" ]]; then
    echo -e "${RED}Error: R2 credentials not set${NC}"
    echo "Please set: R2_ACCESS_KEY_ID and R2_SECRET_ACCESS_KEY"
    echo ""
    echo "Usage: R2_ACCESS_KEY_ID=xxx R2_SECRET_ACCESS_KEY=yyy $0 <module_name>"
    exit 1
fi

# Configuration
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
E2E_ROOT="$(dirname "$SCRIPT_DIR")"
V4_DIR="${E2E_ROOT}/tf/v4"

# Check if v4 directory exists
if [[ ! -d "$V4_DIR" ]]; then
    echo -e "${RED}Error: v4 directory not found at $V4_DIR${NC}"
    exit 1
fi

# Change to v4 directory
cd "$V4_DIR"

# Export R2 credentials for terraform
export AWS_ACCESS_KEY_ID="$R2_ACCESS_KEY_ID"
export AWS_SECRET_ACCESS_KEY="$R2_SECRET_ACCESS_KEY"

echo -e "${CYAN}========================================${NC}"
echo -e "${CYAN}Cleaning Modules from Remote State${NC}"
echo -e "${CYAN}========================================${NC}"
echo ""

# Store modules to clean
MODULES_TO_CLEAN=("$@")
echo -e "${YELLOW}Modules to clean:${NC}"
for module in "${MODULES_TO_CLEAN[@]}"; do
    echo -e "  - ${BLUE}$module${NC}"
done
echo ""

# Pull latest state from remote
echo -e "${YELLOW}Pulling latest state from R2...${NC}"
if ! terraform state pull > terraform.tfstate 2>&1; then
    echo -e "${RED}✗ Failed to pull state from R2${NC}"
    echo ""
    echo -e "${RED}Make sure terraform is initialized:${NC}"
    echo "  cd $V4_DIR"
    echo "  terraform init -reconfigure -backend-config=backend.configured.hcl"
    exit 1
fi
echo -e "${GREEN}✓ State pulled successfully${NC}"

# Count resources before cleanup
TOTAL_BEFORE=$(jq '.resources | length' terraform.tfstate)
echo -e "${BLUE}Total resources before cleanup: $TOTAL_BEFORE${NC}"
echo ""

# Build jq filter to remove all specified modules
JQ_FILTER='.'
for module in "${MODULES_TO_CLEAN[@]}"; do
    JQ_FILTER="$JQ_FILTER | del(.resources[] | select(.module == \"module.$module\"))"
done

# Also increment serial number
JQ_FILTER="$JQ_FILTER | .serial += 1"

# Show resources that will be removed
echo -e "${YELLOW}Resources to be removed:${NC}"
for module in "${MODULES_TO_CLEAN[@]}"; do
    RESOURCES=$(jq -r ".resources[] | select(.module == \"module.$module\") | \"  - \" + .type + \".\" + .name" terraform.tfstate 2>/dev/null || echo "")
    if [[ -n "$RESOURCES" ]]; then
        echo -e "${CYAN}From module.$module:${NC}"
        echo "$RESOURCES"
    else
        echo -e "${YELLOW}  (no resources found in module.$module)${NC}"
    fi
done
echo ""

# Clean the state
echo -e "${YELLOW}Cleaning state...${NC}"
jq "$JQ_FILTER" terraform.tfstate > terraform.tfstate.cleaned
mv terraform.tfstate.cleaned terraform.tfstate

# Count resources after cleanup
TOTAL_AFTER=$(jq '.resources | length' terraform.tfstate)
REMOVED=$((TOTAL_BEFORE - TOTAL_AFTER))

echo -e "${GREEN}✓ State cleaned${NC}"
echo -e "${BLUE}  Before: $TOTAL_BEFORE resources${NC}"
echo -e "${BLUE}  After:  $TOTAL_AFTER resources${NC}"
echo -e "${GREEN}  Removed: $REMOVED resources${NC}"
echo ""

# Verify modules are gone
echo -e "${YELLOW}Verifying modules removed...${NC}"
for module in "${MODULES_TO_CLEAN[@]}"; do
    COUNT=$(jq -r "[.resources[] | select(.module == \"module.$module\")] | length" terraform.tfstate)
    if [[ "$COUNT" -eq 0 ]]; then
        echo -e "${GREEN}✓ module.$module: 0 resources${NC}"
    else
        echo -e "${RED}✗ module.$module: $COUNT resources remaining${NC}"
    fi
done
echo ""

# Push cleaned state back to remote
echo -e "${YELLOW}Pushing cleaned state to R2...${NC}"
if ! terraform state push terraform.tfstate 2>&1; then
    echo -e "${RED}✗ Failed to push state to R2${NC}"
    echo ""
    echo -e "${RED}The local state has been cleaned but not pushed to remote.${NC}"
    echo -e "${YELLOW}You can manually push it with: terraform state push terraform.tfstate${NC}"
    exit 1
fi
echo -e "${GREEN}✓ State pushed successfully${NC}"

echo ""
echo -e "${CYAN}========================================${NC}"
echo -e "${GREEN}✓ Remote State Cleaned!${NC}"
echo -e "${CYAN}========================================${NC}"
echo ""
echo -e "${YELLOW}Summary:${NC}"
echo -e "  - Modules cleaned: ${GREEN}${#MODULES_TO_CLEAN[@]}${NC}"
echo -e "  - Resources removed: ${GREEN}$REMOVED${NC}"
echo -e "  - Resources remaining: ${GREEN}$TOTAL_AFTER${NC}"
echo ""
echo -e "${YELLOW}Next steps:${NC}"
echo -e "  The next time you run terraform plan/apply, it will create"
echo -e "  the resources in these modules from scratch."
echo ""
